\documentclass[a4paper,12pt]{article}
\usepackage[koi8-r]{inputenc}
\usepackage[russian]{babel}
\usepackage{hyperref}
\usepackage{mathtext}
\usepackage[T2A]{fontenc}
\usepackage{array}
\usepackage{tabularx}
\usepackage{longtable}
\usepackage[justification=centering,labelsep=period]{caption}
\usepackage{indentfirst}
\usepackage[pdftex]{graphicx,color}
\usepackage{textcomp}
\usepackage{gnuplot-lua-tikz}
\usepackage{tikz}
\usepackage{amssymb}
\usepackage{amsmath}
% \usepackage{fontogr}
% \usepackage{pscyr}
\usepackage[top=20mm,bottom=20mm,left=20mm,right=20mm]{geometry}



% \renewcommand{\captionlabeldelim} {.}

\makeatletter
\renewcommand\@biblabel[1]{#1.}
\makeatother

\unitlength=1mm

\usepackage{listings} %% собственно, это и есть пакет listings
% \usepackage{caption}
\DeclareCaptionFont{white}{\color{white}} %% это сделает текст заголовка белым
%% код ниже нарисует серую рамочку вокруг заголовка кода.
\DeclareCaptionFormat{listing}{\colorbox{white}{\parbox{\textwidth}{#1#2#3}}}
% \captionsetup[lstlisting]{format=listing,labelfont=black,textfont=black}
\renewcommand{\lstlistingname}{Листинг}


\begin{document}


\usetikzlibrary{arrows}

\lstset{ %
 language=Bash,                 % выбор языка для подсветки (здесь это С)
 basicstyle=\small\ttfamily, % размер и начертание шрифта для подсветки кода
 numbers=left,               % где поставить нумерацию строк (слева\справа)
 numberstyle=\tiny,           % размер шрифта для номеров строк
 stepnumber=1,                   % размер шага между двумя номерами строк
 numbersep=5pt,                % как далеко отстоят номера строк от
 % подсвечиваемого кода
 backgroundcolor=\color{white}, % цвет фона подсветки - используем
 showspaces=false,            % показывать или нет пробелы специальными
% отступами
 showstringspaces=false,      % показывать или нет пробелы в строках
 showtabs=false,             % показывать или нет табуляцию в строках
 frame=single,              % рисовать рамку вокруг кода
 tabsize=2,                 % размер табуляции по умолчанию равен 2 пробелам
 captionpos=t,              % позиция заголовка вверху [t] или внизу [b] 
 breaklines=true,           % автоматически переносить строки (да\нет)
% wordwrap=true,
 breakatwhitespace=false, % переносить строки только если есть пробел
 escapeinside={\%*}{*)}   % если нужно добавить комментарии в коде
 }



\author{Кузнецов В.В., ассистент кафедры ЭИУ1-КФ}
\title{Семинар \No 3 по курсу <<Основы цифровой обработки сигналов>> \\
Быстрое преобразование Фурье}
\maketitle
 
\section{Цель работы} 
 
Целью семинара является вычисление дискретного преобразования Фурье (ДПФ) и
ознакомление с нормировкой результатов ДПФ в среде численных расчётов
GNU/Octave. 

\section{Сведение о дискретном преобразовании Фурье}

\subsection{Определение ДПФ}


Преобразование Фурье нельзя применить к дискретным сигналам. Для спектрального
анализа дискретного (и цифрового) сигнала служит \emph{дискретное
преобразование Фурье --- ДПФ}.

Предположим, что сигнал дискретизирован через равные промежутки времени $T$ и в
результате получена дискретная последовательность из $N$ выборок:
$${x(nT)=x(0),x(T),...,x[(N-1)T]}$$

где $n$ ---  номер выборки, который принимает значения от $n=0$ до $n=N-1$.

Значения $x(nT)$ будут действительными только тогда, когда они представляют
собой значения такого временного ряда как спектр напряжения. В подобном случае
ДПФ последовательности $x(nT)$ можно определить как последовательность
комплексных значений в частотной области:
\begin{equation}
 {X(k\Omega)}=X(0),X(\Omega),\ldots,X[(N-1)\Omega]
\end{equation}

Где $\Omega$ --- частота первой гармоники (при $N\gg 1$), она задаётся как
$1/N$ доля частоты дискретизации:
\begin{equation}
 \Omega=\frac{2\pi}{(N-1)T}\approx \frac{2\pi}{NT}
\end{equation}

Значения ДПФ задаются как:
\begin{equation}
 X(k)=\frac{1}{N} \sum_{n=0}^{N-1} x(nT) e^{-jk\Omega
nT}=\frac{1}{N}\sum_{n=0}^{N-1} x(nT) e^{-jk \frac{2\pi n}{N}},\qquad
k=0,1,\ldots,N-1 \label{DFT}
\end{equation}

Данное выражение называется \emph{прямым ДПФ}. ДПФ обозначается
как $F_D$. Последовательность из $N$ действительных значений во временной
области преобразуется в последовательность из $N$ комплексных значений в
частотной
области. 

Обычно под записью $x(n)$ подразумевают запись $x(nT)$, тем самым переходя к
безразмерной частоте дискретизации. ДПФ тогда запишется в виде:
\begin{equation}
 X(k)=F_D[x(n)]=\frac{1}{N}\sum_{n=0}^{N-1} x(n) e^{-jk \frac{2\pi n}{N}} 
\end{equation}


ДПФ связано со спектром сигнала. Его сравнение с преобразованием Фурье
 показывает, что ДПФ от сигнала $s(t)$ представляет собой отсчёты спектра
$S(\omega)$ этого дискретного сигнала, соответствующие частотам $\omega=\omega_д
k/N$, которые представляют собой доли от частоты дискретизации $\omega_д$.
\begin{equation}
 X(k)=S\left(\frac{2\pi k}{NT}\right)=S\left(\frac{\omega_д n}{N}\right)
\end{equation}

Поэтому ДПФ иногда называют \emph{спектральными отсчётами}. Из данного
соотношения следует вывод, что если добавить к конечному набору отсчётов
некоторое количество нулей, то спектр дискретного сигнала не изменится, но ДПФ
даст больше спектральных отсчётов. Эти отсчёты будут более тесно расположены по
оси частот в интервале от нуля до частоты дискретизации.

Таким образом ДПФ позволяет осуществлять спектральный анализ дискретных сигналов
на ЭВМ и реализовывать, например, цифровой анализатор спектра.

\subsection{Ручное вычисление ДПФ}

Рассмотрим пример вычисления ДПФ вручную. Найдём ДПФ $F_D[x(n)]$ сигнала,
заданного шестью $N=6$
отсчётами $x(n)=(1,1,1,0,0,0)$. Исходный сигнал показан на
рис.\ref{DFT-beispiel}:
\begin{figure}[!ht]
\begin{center}
\begin{tikzpicture}
\draw[-latex](-5mm,0)--(70mm,0) node [anchor=west]{$n$};
\foreach \t / \n / \x / \y in
{0mm/0/1/25mm,10mm/1/1/25mm,20mm/2/1/25mm,30mm/3/0/0mm,40mm/4/0/0mm,50mm/5/0/0mm
}
{
\draw (\t,0mm) node [anchor=north] {\n}--(\t,\y) node [anchor=south] {\x};
\fill (\t,\y) circle (0.7mm);
} 
\end{tikzpicture} 
\end{center}
\caption{Пример дискретного сигнала для вычисления ДПФ.}\label{DFT-beispiel}
\end{figure}


 По выражению (\ref{DFT}) найдём коэффициенты ДПФ для данного сигнала.
$$X(0)=\frac{1}{6}(1+1+1+0+0+0)=\frac{1}{2}$$
$$X(1)=\frac{1}{6}(1+e^{-j\pi/3}+e^{-j2\pi/3}+0+0+0)=\frac{1-j\sqrt{3}}{6}$$
$$X(2)=\frac{1}{6}(1+e^{-j2\pi/3}+e^{-j4\pi/3}+0+0+0)=0$$
$$X(3)=\frac{1}{6}(1+e^{-j3\pi/3}+e^{-j6\pi/3})=\frac{1}{6}$$

Последующие коэффициенты находятся на основании свойства симметричности:
$$X(4)=X^*(2)=0\qquad X(5)=X^*(1)=\frac{1-j\sqrt{3}}{6}$$

Коэффициент $X(0)$ равен постоянной составляющей (среднему значению) сигнала.

\subsection{Обратное ДПФ}

Для того чтобы выполнить дискретное преобразование из частотной области во
временную используется \emph{Обратное дискретное преобразование Фурье ---
ОДПФ}. ОДПФ обозначается символом $F_D^{-1}[]$. Оно определяется по следующему
выражению:

\begin{equation}
 x(nT)=F_D^{-1}[X(k)]=\sum_{k=0}^{N-1}X(k)e^{jk\Omega n
T}=\sum_{k=0}^{N-1}X(k)e^{jk\frac
{2\pi}{N}} \label{invDFT}
\end{equation}

Видно, что данное выражение совпадает с выражением для прямого ДПФ с точностью
до постоянного множителя и отличается от него знаком показателя экспоненты.
Следовательно, для вычисления прямого и обратного ДПФ на ЭВМ может быть
использован один и тот же алгоритм.

Обратное ДПФ по аналогии с обратным преобразованием Фурье позволяет переходить
от спектра к сигналу. По спектральным отсчётам можно восстановить исходный
сигнал. Например ОДПФ позволяет вычислять круговую свёртку на основании
произведений ДПФ сигналов:
\begin{equation}
 f(n)=x(n)\circledast y(n)=F_D^{-1}[X(k)\cdot Y(k)]
\end{equation}

Такой способ вычисления даёт экономию машинных ресурсов по сравнению с прямым
вычислением круговой свёртки, так как при этом выполняется меньше операций.

\subsection{Восстановление сигнала по ДПФ}

Если известна последовательность коэффициентов ДПФ $X(k)$, которая была найдена
по последовательности отсчётов $x(n)$, то по ним может быть найден исходный
сигнал $x(t)$, который был подвергнут дискретизации. Ряд Фурье такого сигнала
из $N$ отсчётов принимает вид с учётом свойства симметричности:
\begin{equation}
\begin{split}
 x(t)=X(0)+2|X(1)|\cos(2\pi t/NT+\varphi_1)+2|X(2)|\cos(4\pi
t/NT+\varphi_2)+\ldots+\\
+|X(N/2)|\cos(N\pi t/NT+\varphi_{N/2})
\end{split}
\end{equation}
где $\varphi_i=\mbox{arg}X(i)$ --- фазовый угол коэффициента ДПФ. В качестве
примера рассмотрим сигнал восстановленный по отсчётам по данным примера
рис.\ref{DFT-beispiel}:
\begin{equation}
 x(t)=\frac{1}{2}+\frac{2}{3}\cos(\frac{\pi
t}{3T}-\frac{\pi}{3})+\frac{1}{6}\cos(\frac{\pi t}{T})
\end{equation}

Осциллограмма восстановленного сигнала показана на рис.\ref{DFT-osc}.
\begin{figure}[!ht]
\begin{center}
\begin{tikzpicture}
\draw [-latex] (0,0)--(80mm,0) node [anchor=west]{$t/NT$};
\draw [-latex] (0,0)--(0mm,30mm) node [anchor=south] {$x(t)$};
\draw [thick, x=0.02cm, y=2.5cm, declare function={
s1(\t)=0.5+0.666*cos(\t-60)+0.1667*cos(3*\t);
}]
plot [domain=0:360, samples=144, smooth] (\x,{s1(\x)}); 
\draw (0,12.5mm) node[anchor=east]{0.5} -- (2.5mm,12.5mm);
\draw (0,25mm) node[anchor=east]{1.0} -- (2.5mm,25mm);
\draw (36mm,0mm) node[anchor=north]{0.5} -- (36mm,2.5mm);
\draw (72mm,0mm) node[anchor=north]{1.0} -- (72mm,2.5mm);
\end{tikzpicture} 
\end{center}
\caption{Сигнал, восстановленный по коэффициентам ДПФ.}\label{DFT-osc}
\end{figure}


\subsection{Быстрое преобразование Фурье}

Для вычисления ДПФ последовательности из $N$ отсчётов требуется произвести
$N^2$ операций с комплексными числами, так каждому из элементов
последовательности $x(n)$ ставится в соответствие элемент $X(k)$, вычисление
которого требует $N$ операций. Вычисления по такому алгоритму для больших
массивов требуют значительных затрат машинного времени. Для преодоления данного
недостатка был разработан алгоритм быстрого преобразования Фурье (БПФ).

При вычислении по алгоритму БПФ требуется обработка входного массива с меньшим
числом элементов. Для вычисления коэффициентов ДПФ для последовательности
из $N$ элементов по алгоритму БПФ требуется $N\log_2 N$ операций. Для
вычислений по методу БПФ требуется массив, содержащий $N=2^p$ отсчётов, где $p$
--- целое число. Такая размерность входных данных удобна для обработки данных
на ЭВМ, так как в двоичной системе счисления числа вида $2^p$ являются
<<круглыми>>. Если входной массив данных не укладывается в такую размерность то
его дополняют нулями.

Если при вычислении ДПФ заменить вычисление одного ДПФ для $N$ отсчётов
вычислением двух ДПФ для двух последовательностей из $N/2$ отсчётов, то число
вычислительных операций уменьшится в два раза. Можно и далее разбивать исходную
последовательности снова пополам, до тех пор пока мы не разобьём её на
последовательности из двух элементов. Для таких последовательностей вычисляется
ДПФ. Чтобы перейти снова к коэффициентам ДПФ для исходной последовательности из
$N$ элементов служат алгоритмы объединения. Схематически данный алгоритм
показан на рис.\ref{FFT-algo}.
\begin{figure}[!ht]
\begin{center}
\begin{tikzpicture}
\foreach \y / \lbl in
{0mm/$x(0)$,10mm/$x(1)$,20mm/$x(2)$,30mm/$x(3)$,40mm/$x(4)$,50mm/$x(5)$,
60mm/$x(6)$,70mm/$x(7)$} 
{
\draw [-latex] (0,\y)node [anchor=east]{\lbl}--(5mm,\y);
}
\draw (5mm,-5mm)rectangle(15mm,75mm);
\node at (7mm,35mm) [anchor=north,rotate=90] {Разбиение};
\foreach \y in {0mm,10mm,20mm,30mm,40mm,50mm,60mm,70mm} 
{
\draw [-latex] (15mm,\y)--(20mm,\y);
}
\draw (20mm,-5mm)rectangle(30mm,32mm);
\draw (20mm,38mm)rectangle(30mm,75mm);
\node at (22mm,60mm) [anchor=north,rotate=90] {Разбиение};
\node at (22mm,10mm) [anchor=north,rotate=90] {Разбиение}; 

\foreach \y in {0mm,10mm,20mm,30mm,40mm,50mm,60mm,70mm} 
{
\draw [-latex] (30mm,\y)--(35mm,\y);
}
\draw (35mm,-5mm)rectangle(45mm,12mm);
\draw (35mm,18mm)rectangle(45mm,32mm);
\draw (35mm,38mm)rectangle(45mm,52mm);
\draw (35mm,58mm)rectangle(45mm,75mm);
\node at (37mm,5mm)  [anchor=north,rotate=90] {Разб.};
\node at (37mm,25mm) [anchor=north,rotate=90] {Разб.};
\node at (37mm,45mm) [anchor=north,rotate=90] {Разб.};
\node at (37mm,65mm) [anchor=north,rotate=90] {Разб.};

\foreach \y in {0mm,10mm,20mm,30mm,40mm,50mm,60mm,70mm} 
{
\draw [-latex] (45mm,\y)--(50mm,\y);
}
\draw (50mm,-5mm)rectangle(75mm,12mm);
\draw (50mm,18mm)rectangle(75mm,32mm);
\draw (50mm,38mm)rectangle(75mm,52mm);
\draw (50mm,58mm)rectangle(75mm,75mm);
\node at (50mm,5mm) [anchor=west] {ДПФ $N=2$};
\node at (50mm,25mm) [anchor=west] {ДПФ $N=2$};
\node at (50mm,45mm) [anchor=west] {ДПФ $N=2$};
\node at (50mm,65mm) [anchor=west] {ДПФ $N=2$};
\foreach \y in {0mm,10mm,20mm,30mm,40mm,50mm,60mm,70mm} 
{
\draw [-latex] (75mm,\y)--(80mm,\y);
}
\draw (80mm,-5mm)rectangle(90mm,12mm);
\draw (80mm,18mm)rectangle(90mm,32mm);
\draw (80mm,38mm)rectangle(90mm,52mm);
\draw (80mm,58mm)rectangle(90mm,75mm);
\node at (82mm,5mm)  [anchor=north,rotate=90] {Объед.};
\node at (82mm,25mm) [anchor=north,rotate=90] {Объед.};
\node at (82mm,45mm) [anchor=north,rotate=90] {Объед.};
\node at (82mm,65mm) [anchor=north,rotate=90] {Объедю};
\foreach \y in {0mm,10mm,20mm,30mm,40mm,50mm,60mm,70mm} 
{
\draw [-latex] (90mm,\y)--(95mm,\y);
}
\draw (95mm,-5mm)rectangle(105mm,32mm);
\draw (95mm,38mm)rectangle(105mm,75mm);
\node at (97mm,60mm) [anchor=north,rotate=90] {Объединение};
\node at (97mm,10mm) [anchor=north,rotate=90] {Объединение};
\foreach \y in {0mm,10mm,20mm,30mm,40mm,50mm,60mm,70mm} 
{
\draw [-latex] (105mm,\y)--(110mm,\y);
}
\draw (110mm,-5mm)rectangle(120mm,75mm);
\node at (112mm,35mm) [anchor=north,rotate=90] {Объединение};
\foreach \y / \lbl in
{0mm/$X(0)$,10mm/$X(1)$,20mm/$X(2)$,30mm/$X(3)$,40mm/$X(4)$,50mm/$X(5)$,
60mm/$X(6)$,70mm/$X(7)$} 
{
\draw [-latex] (120mm,\y)--(125mm,\y)node [anchor=west]{\lbl};
}
\end{tikzpicture}
\end{center}
\caption{Схема вычисления БПФ на примере последовательности из $N$
отсчётов.}\label{FFT-algo}
\end{figure}

Одним из алгоритмов вычисления БПФ является алгоритм с прореживанием по
времени. 

Прореживание по времени заключается в разбиении исходной последовательности
отсчётов $x(n)$ из $N$ элементов на две последовательности $x_0(n)$ и $x_1(n)$
содержащих по $N/2$ отсчётов таким образом, что последовательность $x_0(n)$
содержит отсчёты исходной последовательности с чётными индексами, а
последовательность $x_1(n)$ --- отсчёты исходной последовательности с нечётными
индексами. 



Перепишем выражение для ДПФ в виде:
\begin{equation}
 X(k)=\frac{1}{N}\sum_{n=0}^{N-1}x(n)e^{-j2\pi\frac{kn}{N}}=\frac{1}{N}
\sum_{n=0}^{N-1}x(n)W^{nk}_N
\end{equation}

Обозначение $W^{nk}_N$ называется поворотным коэффициентом:
\begin{equation}
 W^{nk}_N=e^{\frac{-j2\pi n k}{N}}
\end{equation}

Рассмотрим ДПФ сигнала прореженного по времени. Его можно представить в виде
суммы ДПФ от двух половинок сигнала (сумма разбивается на две суммы):
\begin{equation}
 X(k)=\sum_{n=0}^{N/2-1}x(2n)W^{2nk}_N+\sum_{n=0}^{N/2-1}x(2n+1)W^{(2n+1)k}_N=
\sum_{n=0}^{N/2-1}x(2n)W^{2nk}_N+W^k_N\sum_{n=0}^{N/2-1}x(2n+1)W^{2nk}_N
\label{DFT_halb}
\end{equation}

Если рассмотреть только первую половину спектра $X(k)$ при $k=0\ldots N/2$ и
учесть периодичность поворотных коэффициентов:
\begin{equation}
 W^{2nk}_N=e^{-j\frac{2\pi}{N}2nk}=W^{nk}_{N/2}
\end{equation}

тогда можно (\ref{DFT_halb}) записать как:
\begin{equation}
 X(k)=\sum_{n=0}^{N/2-1}x(2n)W^{nk}_{N/2}+W^k_N\sum_{n=0}^{N/2-1}x(2n+1)W^{2nk}_
{N/2}=X_0(k)+W^k_N X_1(k)
\end{equation}
\begin{equation}
 X_0(k)=\sum_{n=0}^{N/2-1}x_0(n)W^{nk}_{N/2}
 X_1(k)=\sum_{n=0}^{N/2-1}x_1(n)W^{nk}_{N/2}
\end{equation}

Где $X_0(k)$ и $X_1(k)$ --- две $N/2$-точечные ДПФ от <<чётной>> и <<нечётной>>
половин исходной последовательности.

Таким образом прореживание по времени можно считать алгоритмом разбиения
последовательности на две половинной длительности. Первая половина
объединённого спектра есть сумма спектра <<чётной>> последовательности и спектра
<<нечётной>> последовательности, умноженного на поворотные коэффициенты. Таким
образом сокращается число операций умножения комплексных чисел и экономится
машинное время.

Рассмотри вторую половину спектра $X(k+N/2)$, $k=0\ldots N/2-1$:
\begin{equation}
 X(k+N/2)=\sum_{n=0}^{N/2-1}x(2n)W^{n(k+N/2)}_{N/2}+W^{k+N/2}_{N/2}
\sum_{n=0}^{N/2-1}x(2n+1)W^{n(k+N/2)}_{N/2} \label{spektrum-zweite}
\end{equation}

Рассмотрим множитель:
\begin{equation}
 W^{n(k+N/2)}_{N/2}=W^{nN/2}_{N/2}W^{nk}_{N/2}
\end{equation}


Учтём, что:
\begin{equation}
 W^{nN/2}_{N/2}=e^{-j\frac{2\pi n N/2}{N/2}}=e^{-j2\pi n}=1
\end{equation}

Рассмотри поворотный коэффициент в выражении (\ref{spektrum-zweite}):
\begin{equation}
 W^{k+N/2}_N=W^{N/2}_N W^k_N=e^{-j\frac{2\pi N}{2 N}}W^k_N=-W^k_N
\end{equation}

Тогда выражение (\ref{spektrum-zweite}) принимает вид:
\begin{equation}
X(k+N/2)=\sum_{n=0}^{N/2-1}x(2n)W^{nk}_{N/2}-W^k_N\sum_{n=0}^{N/2-1}x(2n+1)
W^{nk}_{N/2}=X_0(k)-W^k_N X_1(k) 
\end{equation}

Окончательно можно записать:
\begin{equation}
 X(k)=X_0(k)+W^k_N X_1(k) \label{1FFT}
\end{equation}
\begin{equation}
 X(k+N/2)=X_0(k)-W^k_N X_1(k) \label{2FFT}
\end{equation}

Выражения (\ref{1FFT}) и (\ref{2FFT}) представляют собой алгоритм объединения
при прореживании по времени. Данную процедуру можно представить в виде графа
(рис.\ref{FFT-bab}), который имеет характерную форму. Поэтому данный алгоритм
называется <<бабочка>>. 
\begin{figure}[!ht]
\begin{center}
\begin{tikzpicture}
\node (X0) at (0,0) [draw] {$X_0(k)$};
\node (X1) at (0,-20mm) [draw] {$W^k_N X_1(k)$};
\node (X11)  at (30mm,0) [anchor=west,draw] {$X(k)=X_0(k)+W^k_N X_1(k)$};
\node (X12) at (30mm,-20mm) [anchor=west,draw] {$X(k+N/2)=X_0(k)-W_N^kX_1(k)$};
\draw [-latex] (X0)--(X11);
\draw [-latex] (X0)--(X12);
\draw [-latex] (X1)--(X12);
\draw [-latex] (X1)--(X11);
\end{tikzpicture}
\end{center}
\caption{Процедура объединения на основе графа <<бабочка>>.}\label{FFT-bab}
\end{figure}

ДПФ сигнала прореженного по времени можно представить в виде
суммы ДПФ от двух половинок сигнала (сумма разбивается на две суммы).

Графически данный алгоритм можно представить как показано на
рис.\ref{FFT1}.

\begin{figure}[!ht]
\begin{center}
\begin{tikzpicture}
\node (x0) [draw]  at (0,0mm) {$x(0)$};
\node (x1) [draw]  at (0,-15mm) {$x(1)$};
\node (x2) [draw]  at (0,-30mm) {$x(2)$};
\node (x3) [draw]  at (0,-45mm) {$x(3)$};
\node (x4) [draw]  at (0,-60mm) {$x(4)$};
\node (x5) [draw]  at (0,-75mm) {$x(5)$};
\node (x6) [draw]  at (0,-90mm) {$x(6)$}; 
\node (x7) [draw]  at (0,-105mm) {$x(7)$};

\node (x01) [draw]  at (20mm,0mm) {$x(0)$};
\node (x21) [draw]  at (20mm,-15mm) {$x(2)$};
\node (x41) [draw]  at (20mm,-30mm) {$x(4)$};
\node (x61) [draw]  at (20mm,-45mm) {$x(6)$};
\node (x11) [draw]  at (20mm,-60mm) {$x(1)$};
\node (x31) [draw]  at (20mm,-75mm) {$x(3)$};
\node (x51) [draw]  at (20mm,-90mm) {$x(5)$};
\node (x71) [draw]  at (20mm,-105mm) {$x(7)$};

\draw [-latex] (x0.east)--(x01.west);
\draw [-latex] (x1.east)--(x11.west);
\draw [-latex] (x2.east)--(x21.west);
\draw [-latex] (x3.east)--(x31.west);
\draw [-latex] (x4.east)--(x41.west);
\draw [-latex] (x5.east)--(x51.west);
\draw [-latex] (x6.east)--(x61.west);
\draw [-latex] (x7.east)--(x71.west);

\node (x02) [draw]  at (40mm,0mm) {$x(0)$};
\node (x42) [draw]  at (40mm,-15mm) {$x(4)$};
\node (x22) [draw]  at (40mm,-30mm) {$x(2)$};
\node (x62) [draw]  at (40mm,-45mm) {$x(6)$};
\node (x12) [draw]  at (40mm,-60mm) {$x(1)$};
\node (x52) [draw]  at (40mm,-75mm) {$x(5)$};
\node (x32) [draw]  at (40mm,-90mm) {$x(3)$};
\node (x72) [draw]  at (40mm,-105mm) {$x(7)$};

\draw [-latex] (x01.east)--(x02.west);
\draw [-latex] (x11.east)--(x12.west);
\draw [-latex] (x21.east)--(x22.west);
\draw [-latex] (x31.east)--(x32.west);
\draw [-latex] (x41.east)--(x42.west);
\draw [-latex] (x51.east)--(x52.west);
\draw [-latex] (x61.east)--(x62.west);
\draw [-latex] (x71.east)--(x72.west);

\node (X000) [draw]  at (60mm,0mm) {$X_{00}(0)$};
\node (X001) [draw]  at (60mm,-15mm) {$X_{00}(1)$};
\node (X010) [draw]  at (60mm,-30mm) {$X_{01}(0)$};
\node (X011) [draw]  at (60mm,-45mm) {$X_{01}(1)$};
\node (X100) [draw]  at (60mm,-60mm) {$X_{10}(0)$};
\node (X101) [draw]  at (60mm,-75mm) {$X_{10}(1)$};
\node (X110) [draw]  at (60mm,-90mm) {$X_{11}(0)$};
\node (X111) [draw]  at (60mm,-105mm) {$X_{11}(1)$};

\draw [-latex] (x02.east)--(X000.west);
\draw [-latex] (x02.east)--(X001.west);
\draw [-latex] (x42.east)--(X000.west);
\draw [-latex] (x42.east)--(X001.west);

\draw [-latex] (x22.east)--(X010.west);
\draw [-latex] (x22.east)--(X011.west);
\draw [-latex] (x62.east)--(X010.west);
\draw [-latex] (x62.east)--(X011.west);

\draw [-latex] (x12.east)--(X100.west);
\draw [-latex] (x12.east)--(X101.west);
\draw [-latex] (x52.east)--(X100.west);
\draw [-latex] (x52.east)--(X101.west);

\draw [-latex] (x32.east)--(X110.west);
\draw [-latex] (x32.east)--(X111.west);
\draw [-latex] (x72.east)--(X110.west);
\draw [-latex] (x72.east)--(X111.west);

\node (X00) [draw]  at (95mm,0mm) {$X_{0}(0)$};
\node (X01) [draw]  at (95mm,-15mm) {$X_{0}(1)$};
\node (X02) [draw]  at (95mm,-30mm) {$X_{0}(2)$};
\node (X03) [draw]  at (95mm,-45mm) {$X_{0}(3)$};
\node (X10) [draw]  at (95mm,-60mm) {$X_{1}(0)$};
\node (X11) [draw]  at (95mm,-75mm) {$X_{1}(1)$};
\node (X12) [draw]  at (95mm,-90mm) {$X_{1}(2)$};
\node (X13) [draw]  at (95mm,-105mm) {$X_{1}(3)$};

\draw [-latex] (X000.east)--(X00.west);
\draw [-latex] (X000.east)--(X02.west);
\draw [-latex] (X001.east)--(X01.west);
\draw [-latex] (X001.east)--(X03.west);
\draw [-latex] (X010.east)--(X00.west);
\draw [-latex] (X010.east)--(X02.west);
\draw [-latex] (X011.east)--(X01.west);
\draw [-latex] (X011.east)--(X03.west);

\draw [-latex] (X100.east)--(X10.west);
\draw [-latex] (X100.east)--(X12.west);
\draw [-latex] (X101.east)--(X11.west);
\draw [-latex] (X101.east)--(X13.west);
\draw [-latex] (X110.east)--(X10.west);
\draw [-latex] (X110.east)--(X12.west);
\draw [-latex] (X111.east)--(X11.west);
\draw [-latex] (X111.east)--(X13.west);

\node (fX0) [draw] at (130mm,0mm) [anchor=west] {$X(0)$};
\node (fX1) [draw]  at (130mm,-15mm) [anchor=west] {$X(1)$};
\node (fX2) [draw]  at (130mm,-30mm) [anchor=west] {$X(2)$};
\node (fX3) [draw]  at (130mm,-45mm) [anchor=west] {$X(3)$};
\node (fX4) [draw]  at (130mm,-60mm) [anchor=west] {$X(4)$};
\node (fX5) [draw]  at (130mm,-75mm) [anchor=west] {$X(5)$};
\node (fX6) [draw]  at (130mm,-90mm) [anchor=west] {$X(6)$};
\node (fX7) [draw]  at (130mm,-105mm) [anchor=west] {$X(7)$};

\draw [-latex] (X00.east)--(fX0.west);
\draw [-latex] (X00.east)--(fX4.west);
\draw [-latex] (X01.east)--(fX1.west);
\draw [-latex] (X01.east)--(fX5.west);
\draw [-latex] (X02.east)--(fX2.west);
\draw [-latex] (X02.east)--(fX6.west);
\draw [-latex] (X03.east)--(fX3.west);
\draw [-latex] (X03.east)--(fX7.west);

\draw [-latex] (X10.east)--(fX4.west);
\draw [-latex] (X10.east)--(fX0.west);
\draw [-latex] (X11.east)--(fX1.west);
\draw [-latex] (X11.east)--(fX5.west);
\draw [-latex] (X12.east)--(fX2.west);
\draw [-latex] (X12.east)--(fX6.west);
\draw [-latex] (X13.east)--(fX3.west);
\draw [-latex] (X13.east)--(fX7.west);
\end{tikzpicture}
\end{center}
\caption{Алгоритм ДПФ с прореживанием по времени. Пример для
последовательности из $N=8$ элементов.}\label{FFT1}
\end{figure}

После перестановок получаем четыре 2-х точечных ДПФ:
\begin{eqnarray}
 X_{00}(0)&=&x(0)+W_2^0x(4)\\
 X_{00}(1)&=&x(0)-W_2^0x(4)\\
 X_{01}(0)&=&x(2)+W_2^0x(6)\\
 X_{01}(1)&=&x(2)-W_2^0x(6)\\
 X_{10}(0)&=&x(1)+W_2^0x(5)\\
 X_{10}(1)&=&x(1)-W_2^0x(5)\\
 X_{11}(0)&=&x(3)+W_2^0x(7)\\
 X_{11}(1)&=&x(3)+W_2^0x(7)
\end{eqnarray}

На основе четырёх двухточечных ДПФ формируется два четырёхточечные ДПФ:
\begin{eqnarray}
 X_0(0)&=&X_{00}(0)+W^0_4X_{01}(0)\\
 X_0(1)&=&X_{00}(1)+W^1_4X_{01}(1)\\
 X_0(2)&=&X_{00}(0)-W^0_4X_{01}(0)\\
 X_0(3)&=&X_{00}(1)-W^1_4X_{01}(1)\\
 X_1(0)&=&X_{10}(0)+W^0_4X_{11}(0)\\
 X_1(1)&=&X_{10}(1)+W^1_4S_{11}(1)\\
 X_1(2)&=&X_{10}(0)-W^0_4S_{11}(0)\\
 X_1(3)&=&X_{10}(1)-W^1_4S_{01}(1)
\end{eqnarray}

На последнем уровне формируется полный спектр входного сигнала:
\begin{eqnarray}
 X(0)&=&X_0(0)+W^0_8 X_1(0)\\
 X(1)&=&X_0(1)+W^1_8 X_1(1)\\
 X(2)&=&X_0(2)+W^2_8 X_1(2)\\
 X(3)&=&X_0(3)+W^3_8 X_1(3)\\
 X(0)&=&X_0(0)-W^0_8 X_1(0)\\
 X(1)&=&X_0(1)-W^1_8 X_1(1)\\
 X(2)&=&X_0(2)-W^2_8 X_1(2)\\
 X(3)&=&X_0(3)-W^3_8 X_1(3)
\end{eqnarray}





Таким образом прореживание по времени можно считать алгоритмом разбиения
последовательности на две половинной длительности. Первая половина
объединённого спектра есть сумма спектра <<чётной>> последовательности и спектра
<<нечётной>> последовательности, умноженного на поворотные коэффициенты. Таким
образом сокращается число операций умножения комплексных чисел и экономится
машинное время.

\section{Реализация ДПФ}

В качестве алгоритма вычисления ДПФ обычно применяется быстрое преобразование
Фурье (БПФ, Fast Fourier Transform --- FFT).

Реализация БПФ на современных ЭВМ имеет свои особенности. Для этого
используются или среды численной математики подобные MATLAB (GNU/Octave), или
реализация на языке С/C++ при помощи библиотек, подобных \verb|libfftw3|.

Рассмотрим пример реализации ДПФ в среде численной математики GNU/Octave.
Для вычисления ДПФ сигнала служит функция \verb|fft()|. В качестве параметра на
вход функции нужно передать вектор, содержащий отсчёты сигнала. Вторым
параметром функции служит число отсчётов ДПФ. Этот параметр может отсутствовать.


Пример скрипта для реализации ДПФ суммы двух синусоидальных сигналов приведён в
листинге \ref{FFT-octave}. Скрипт строит графики двухтонального сигнала с
постоянной составляющей и его спектра. На рис.\ref{FFT-octave-erg} показан
результат выполнения скрипта.

\lstset{language=Bash}
\begin{lstlisting}[caption=Скрипт на GNU/Octave для реализации построения
вычисления спектра сигнала., label=FFT-octave ]
#!/usr/bin/octave -qf
Ns=1000; # число отсчётов сигнала
F1=100; # частота первого тона 100 Гц
F2=200; # частота второго тона 200 гц
dur=0.5; # длительность сигнала 0.5 сек
A0=0.6; # постоянная составляющая 0.6 В
A1=0.8; # амплиткда первого тона 0.8 В
A2=1.4; # амплитуда второго тона 1.4В
An=6; # амплитуда шума 6 В
Fs=Ns/dur; # частота дисктеризации. Делим число выборок 
# на длительность сигнала.
t=(0:dur/Ns:dur)'; # создаём вектор из 2000 отсчёов по вермени
Signal=A0 + A1*sin(2*pi*F1*t) + A2*sin(2*pi*F2*t); # сигнал
# Сигнал состоит из постоянной составляющей и двух тонов амплитудой
# А1 и A2
S=fft(Signal); # вычисляем ДПФ, то есть спектр
F=0:(Fs/Ns):Fs; # частота
subplot(2,1,1); 
plot(t,Signal); # строим график сигнала
subplot(2,1,2);
plot(F,abs(S)); # строим график спектра
pause; 
\end{lstlisting}

\begin{figure}[!ht]
\input{../DSP/Spectrum1.tex}
\caption{Результат применения функции fft к двухтональному
сигналу} \label{FFT-octave-erg}
\end{figure}

Из рисунка видим, что спектр сигнала состоит из двух зеркальных половинок.
Правая часть спектра в интервале частот от $F_s/2$ до $F_s$ соответствуют
отрицательным частотам, которые не имеют физического смысла. И эта часть
спектра никакой дополнительной информации о сигнале не несёт. Поэтому её можно
отбросить. Амплитуды гармоник распределяются по двум половинам спектра и каждую
амплитуду, кроме постоянной составляющей соответствующей нулевой частоте, после
отбрасывания половины спектра нужно умножить в два раза.

Как видно из определения ДПФ (\ref{DFT}), при вычислении ДПФ происходит
суммирование всех отсчётов сигналов, поэтому амплитуды получившихся гармоник
будут в $N$ (число отсчётов сигнала) раз больше, чем составляющих исходного
спектра. Поэтому амплитуду каждой из гармоник нужно разделить на $N$.

Вышеизложенные операции называются нормировкой результата ДПФ. Нормировка
повышает наглядность представления спектра. После нормировки видно, из каких
амплитуд состоит сигнал. Скрипт для нормировки ДПФ из предыдущего примера
приведён в листинге \ref{FFT-norm}, результат выполнения скрипта показан на
рис.\ref{FFT-norm-erg}.

\lstset{language=Bash}
\begin{lstlisting}[caption=Скрипт на GNU/Octave для реализации построения
вычисления спектра сигнала., label=FFT-norm ]
#!/usr/bin/octave -qf
pkg load signal
Ns=1000; # число отсчётов сигнала
F1=100; # частота первого тона 100 Гц
F2=200; # частота второго тона 200 гц
dur=0.5; # длительность сигнала 0.5 сек
A0=0.6; # постоянная составляющая 0.6 В
A1=0.8; # амплиткда первого тона 0.8 В
A2=1.4; # амплитуда второго тона 1.4В
An=6; # амплитуда шума 6 В
Fs=Ns/dur; # частота дискретизации. Делим число выборок 
# на длительность сигнала.
t=(0:dur/Ns:dur)'; # создаём вектор из 2000 отсчёов по вермени
Signal=A0 + A1*sin(2*pi*F1*t) + A2*sin(2*pi*F2*t); # сигнал
# Сишнал состоит из постоянной составляющей и двух тонов амплитудой
# А1 и A2
S=fft(Signal); # вычисляем ДПФ, то есть спектр
S=(2/Ns)*abs(S(1:Ns/2)); # отсекаем половину спектра, которая не несёт полезной
информации
S(1)=0.5*S(1); # нормируем постоянную составляющую
F=0:(Fs/Ns):Fs-1; # частота
F=F(1:(length(F)/2)); # отсекаем половину частоты

subplot(2,1,1); 
plot(t,Signal); # строим график сигнала
subplot(2,1,2);
plot(F,abs(S)); # строим график спектра
axis([0,300]);

pause;
\end{lstlisting}

\begin{figure}[!ht]
\input{../DSP/Spectrum2.tex}
\caption{Нормировка результата применения функции fft к двухтональному
сигналу} \label{FFT-norm-erg}
\end{figure}

Из рисунка видно, что спектр состоит из трёх пиков. Первый пик расположен на
частоте $f=0$ и имеет амплитуду 0,6 В. Он соответствует постоянной
составляющей. Второй пик расположен на частоте 100 Гц и имеет амплитуду 0,8 В.
Он соответствует первому тону частотой 100 Гц. Третий пик расположен на частоте
200 Гц и имеет амплитуду 1,4 В. Он соответствует второму тону частотой 200 Гц.
Таким образом на спектре видим, что сигнал состоит из двух синусоидальных
сигналов и постоянной составляющей. 

\section{Задание для самостоятельной работы}

Вычислить ДПФ для суммы двух сигналов и постоянной составляющей. Частоты
сигналов в Герцах (Гц) вычисляются по формулам:

Для группы РПД-91:
\begin{equation}
 f_1=20N,\qquad Гц
 f_2=30N,\qquad Гц
\end{equation}

Для группы РПД\_С-91:
\begin{equation}
 f_1=25N, \qquad Гц
 f_2=32N,\qquad Гц
\end{equation}

Амплитуды сигналов и постоянной составляющей взять по своему усмотрению в
пределах от 0 до 3 В. 

\end{document}
